---
layout: page
title: xwMOOC 모형
subtitle: "`caret` 예측모형 개발"
author:
    name: xwMOOC
    url: https://www.facebook.com/groups/tidyverse/
    affiliation: Tidyverse Korea
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
    toc_float: true
    highlight: tango
    code_folding: show
    number_section: true
    self_contained: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE,
                      comment="", digits = 3, tidy = FALSE, prompt = FALSE, fig.align = 'center')

```


# 기계학습 예측모형 기본기 [^best-algorithm] [^applied-predictive-modeling] {#predictive-model}

## `caret` 팩키지 {#predictive-model-caret}

`caret` 팩키지는 10년이 넘는 기간에 걸쳐 꾸준히 개발되면서 인기를 얻어 안정성이 검증된 팩키지로 
예측모형에 있어 독보적인 영역을 구축하고 있는 팩키지다. 
`caret`을 잘 사용하기 위해서는 기계학습 예측모형에 대한 기본기와 함께 모형개발에 대한 경험도 필요하다.
오로지 예측성능을 극대화하는데 초점을 맞춰 개발되었기 때문에 이를 항상 염두에 두고 팩키지를 사용한다.
예측데이터를 `basetable` 형태로 맞는 다음에 `createDataPartition()`, `createMultiFolds()`, `trainControl()`을 사용해서 
데이터와 초모수(hyper parameter)에 대한 준비를 한 후에 예측모형으로 `glmnet`, `SVM`, `ranger`, `gbm`, `xgBoost`를 
핵심 모형 아키텍처로 지정하여 가장 성능이 뛰어난 예측모형을 구축한다. 
이 과정에서 당연히 CV를 통해 잡아내지 못하는 초모수도 모형튜닝을 통해서 함께 `tuneGrid`에 지정하여 찾아낸다.
그리고 나서 `resamples()` 함수를 사용해서 가장 예측력이 뛰어난 예측모형을 개발하고 이를 `plumber`를 통해 배포한다.

<img src="fig/caret-framework.png" alt="caret 프레임워크" width="100%" />

## 기계학습 예측모형 선택 [^best-algorithm] [^applied-predictive-modeling] {#predictive-model}

[^applied-predictive-modeling]: [Kuhn, Max, and Kjell Johnson. Applied predictive modeling. New York: Springer, 2013.](http://link.springer.com/book/10.1007/978-1-4614-6849-3)

[^best-algorithm]: [Randal S. Olson, William La Cava, Zairah Mustahsan, Akshay Varik, Jason H. Moore(2018), "Data-driven Advice for Applying Machine Learning to Bioinformatics Problems"](https://arxiv.org/abs/1708.05070v1)

기계학습 모형을 선정할 때, 인간이 사용하는 경우 **성능 상한(Performance Ceiling)** 을 가장 복잡한 모형으로 잡고, 
컴퓨팅 복잡성, 예측 용이성, 해석 편이성을 고려하여 모형을 선정한다. 
예를 들어, 비선형 지지도 벡터 머신(Nonlinear SVM) 혹은 확률숲(Random Forest)의 경우 데이터에 대한 접합은 좋지만, 
실제 운영환경으로 배포하기가 그다지 좋지는 못하다.

1. 분류문제(classification) 이항회귀모형과 연속형 예측 선형회귀모형은 최종적으로 선정되는 예측모형과 벤치마크 성능을 비교하는 지표로 필히 실행하여 선정한다.
1. 기계학습 모형을 최종 모형으로 선정할 때 해석용이성은 떨어지지만, 가장 성능이 좋은 모형으로 선정한다.
예를 들어, 부스팅 나무모형(Boosting Tree Models), 지지도 벡터 머신(Support Vector Machine, SVM)으로 시작하는데 이유는 가장 정확한 최적의 결과를 제공하기 때문이다.
1. 최적의 모형이 어떻게 보면 가장 좋은 성능의 상한을 제시하게 되고, 이를 기반으로 최적의 성능에 버금가는 해석이 용이한 모형을 탐색한다. 
예를 들어, multivariate adaptive regression splines (MARS), partial least squares, generalized additive models, 나이브 베이즈 모형이 대표적이다.
1. 성능은 복잡성이 높은 모형이 기준이 되고, 검토하는 모형은 가장 단순한 모형으로 선정한다.

## 각 단계별 데이터셋 [^applied-predictive-modeling] {#predictive-model-dataset}

데이터셋을 훈련(train), 타당성검증(validation), 시험(test) 데이터셋을 나누고 
데이터의 역할에 맞게 기계학습 모형 선정에 필요한 기능을 갖추는데 활용한다.
훈련 데이터, 타당성검증 데이터, 시험 데이터는 많은 경우 6:2:2 비율로 나누는 방법이 과거 많이 사용되었다.
현재는 타당성검증 데이터를 활용하여 모형을 하나만 개발하는 것이 아니라 10-fold 교차검증을 5번 반복하는 것이 좋은 성능을 낸다는 연구결과도 있어서
이를 통해서 최적의 모형을 발견한 후에 시험 데이터셋으로 예측모형의 성능을 확정한다.

<img src="fig/ml-caret-yardstick.png" alt="기계학습 모형선정 및 평가" width="57%" />


# 예측모형 개발 사례 {#german-credit-data}

## 독일신용평가 데이터 {#german-credit-data-import}

독일신용평가 데이터를 `caret` 팩키지에 포함된 것을 사용한다. 훈련데이터와 검증데이터를 반반 나눈다.
`createDataPartition` 함수를 사용해서 쉽게 사용한다. `sample` 함수를 사용해도 좋다.
데이터 전처리가 깔끔히 되어 있으니 생략한다. 필요하면 더 작업을 해도 좋다.

```{r german-credit-data-configuration}
# 0. 환경설정 ------
library(caret)
library(tidyverse)
library(yardstick)

# 1. 데이터 ------
## 1.1. 데이터 가져오기
data(GermanCredit)
```

## 데이터 분할 {#german-credit-data-split}

`createDataPartition()` 함수를 사용해서 데이터를 훈련과 시험데이터로 나누고,
`createMultiFolds()` 함수를 사용해서 훈련데이터를 다시 모형개발에 사용되는 데이터와 모형 검증에 사용되는 CV 데이터로 나눈다.


```{r german-credit-data-split}
## 1.2. 데이터 분할: 훈련, 타당성검증, 시험
### 훈련 vs 검증/시험
in_train <- createDataPartition(GermanCredit$Class, p = c(0.6, 0.4), list = FALSE)

training <- GermanCredit[in_train, ]
validation_test <- GermanCredit[-in_train, ]

### 타당성검증 vs 시험
in_test <- createDataPartition(validation_test$Class, p = c(0.5, 0.5), list = FALSE)

validation <- validation_test[-in_test, ]
testing <- validation_test[in_test, ]
```

## 3.3. 모형공식 {#german-credit-model-formula}

R에 공식 비공식적으로 10,000개가 넘는 팩키지가 존재하고 각 팩키지마다 모형을 명세하는 방식이 다르다.
크게 `~` 공식을 사용하는 방식과 데이터프레임 `=` 을 사용하는 방식이 있는데 팩키지마다 공식을 명세하는 방식을 준용하면 된다. 
중요한 것은 `~`, `=` 좌측은 종속변수, 우측은 독립변수가 위치해 넣으면 된다.

```{r german-credit-formula}
# 2. 예측모형 개발 ------
## 2.1. 예측모형 공식 

credit_var <- setdiff(colnames(training), list('Class'))
credit_formula <- as.formula(paste('Class', paste(credit_var, collapse=' + '), sep=' ~ '))
```

## 3.4. 모형 아키텍처 {#german-credit-model-architecture}

일반화선형모형(GLM)을 벤치마킹 기본 모형으로 잡고, 
독일신용평가 데이터는 분류문제로 CART 모형도 예측모형에 포함하고 
`Random Forest`, GBM, xgBoost를 선택해야하는 모형 아키텍처에 포함시킨다. 
모형을 차례로 적합시켜 **성능**은 가장 뛰어나면서, 

1. 가장 단순한 모형
1. 가장 이해하기 쉬운 모형
1. 가장 실운영환경에 배포하기 좋은 모형

이런 모형을 선정한다. 이를 위한 판단기준으로 타당성검증(validation) 데이터를 활용한다.
타당성검증(validation) 데이터는 물론 훈련과정에 포함된 적은 없다.

`trainControl()` 함수에 `method = 'cv'`로 설정하게 되면 10-fold 가 지정된다.
이를 반복해서 5회하는 것이 성능이 좋은 것으로 알려져 있다.

```{r german-credit-model-architecture}
## 2.2. 예측모형 아키텍처 
ml_control <- trainControl(method = "repeatedcv", 
                           number = 10, 
                           repeats = 5,
                           sampling = "up",
                           verboseIter=FALSE)

### 2.2.1. 벤치마크 모형 - 이항회귀모형 적합
glm_m <- train(credit_formula, data = training,
                        method = "glm", family=binomial(link='logit'),
                        trControl = ml_control)

### 2.2.2. 의사결정나무모형(cart)
cart_m <- train(credit_formula, data = training,
                method = "rpart",
                trControl = trainControl(method = "none",
                                         sampling = "up"))

### 2.2.3. 확률숲(Random Forest)
rf_m <- train(credit_formula, data = training,
                 method = "rf",
                 trControl = ml_control)

### 2.2.4. gbm
gbm_m <- train(credit_formula, data = training,
                     method = "gbm",
                     trControl = ml_control,
                     verbose = FALSE)

### 2.2.5. xgBoost
xgboost_m <- train(credit_formula, data = training,
                     method = "xgbLinear",
                     trControl = ml_control)
```



## 3.5. 모형 아키텍처 선정 {#german-credit-model-choose}

이항회귀모형, 의사결정나무, 확률숲(randomForest), GBM, xgBoost 모형의 성능을 정확도(accuracy)를 기준으로 각각 비교한다.

```{r german-credit-choose-model}
## 2.3. 모형 아키텍처 선정 
model_arch <- validation %>%
    mutate(GLM = predict(glm_m, validation),
           CART = predict(cart_m, validation),
           RF = predict(rf_m, validation),
           XGB = predict(xgboost_m, validation),
           GBM = predict(gbm_m, validation))

metrics(model_arch, truth = Class, estimate = GLM)
metrics(model_arch, truth = Class, estimate = CART)
metrics(model_arch, truth = Class, estimate = RF)
metrics(model_arch, truth = Class, estimate = GBM)
metrics(model_arch, truth = Class, estimate = XGB)

# predict(glm_m, validation, type="prob")
```

사실 모형 아키텍처에 포함된 모든 모형이 동일한 값을 주지는 않는다.
차이가 크다고 하더라도 확률적인 요인에 의한 차이로 밝혀질 수도 있다. 
이런 경우 쌍체 $t$-검증 (paired t-test)을 사용하여 모형간 유의성을 검증한다.
만약 차이점이 없다면 가장 단순한 모형을 선택한다.

```{r german-credit-choose-model-test}
diff_test <- resamples(list(GLM = glm_m, 
                            XGB = xgboost_m))
summary(diff_test)

diff(diff_test) %>% summary
```

## 3.6. 최종 모형 성능 {#german-credit-model-choose}

최종적으로 모형의 성능을 `testing` 검증데이터를 통해서 사전에 선정한 측도(정확도, `accuracy`)를 통해 반영한다.
`xgboost` 모형과 `GLM` 모형의 차이만큼을 모형 성능으로 보고 이를 예측모형으로 적용시킨다.

```{r german-credit-model-performance}
# 3. 모형성능 ------
testing_perf <- testing %>%
    mutate(GLM = predict(glm_m, testing),
           XGB = predict(xgboost_m, testing))

metrics(testing_perf, truth = Class, estimate = GLM)
metrics(testing_perf, truth = Class, estimate = XGB)
```